// Copyright 2018-2023 CERN
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// In applying this license, CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: cs3/sharing/link/v1beta1/link_api.proto

package linkv1beta1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	LinkAPI_CreatePublicShare_FullMethodName     = "/cs3.sharing.link.v1beta1.LinkAPI/CreatePublicShare"
	LinkAPI_RemovePublicShare_FullMethodName     = "/cs3.sharing.link.v1beta1.LinkAPI/RemovePublicShare"
	LinkAPI_GetPublicShare_FullMethodName        = "/cs3.sharing.link.v1beta1.LinkAPI/GetPublicShare"
	LinkAPI_GetPublicShareByToken_FullMethodName = "/cs3.sharing.link.v1beta1.LinkAPI/GetPublicShareByToken"
	LinkAPI_ListPublicShares_FullMethodName      = "/cs3.sharing.link.v1beta1.LinkAPI/ListPublicShares"
	LinkAPI_UpdatePublicShare_FullMethodName     = "/cs3.sharing.link.v1beta1.LinkAPI/UpdatePublicShare"
)

// LinkAPIClient is the client API for LinkAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LinkAPIClient interface {
	// Creates a new share.
	// MUST return CODE_NOT_FOUND if the resource reference does not exist.
	// MUST return CODE_ALREADY_EXISTS if the share already exists for the 4-tuple consisting of
	// (owner, shared_resource, grantee).
	// New shares MUST be created in the state SHARE_STATE_PENDING.
	CreatePublicShare(ctx context.Context, in *CreatePublicShareRequest, opts ...grpc.CallOption) (*CreatePublicShareResponse, error)
	// Removes a share.
	// MUST return CODE_NOT_FOUND if the share reference does not exist.
	RemovePublicShare(ctx context.Context, in *RemovePublicShareRequest, opts ...grpc.CallOption) (*RemovePublicShareResponse, error)
	// Gets share information for a single share.
	// MUST return CODE_NOT_FOUND if the share reference does not exist.
	GetPublicShare(ctx context.Context, in *GetPublicShareRequest, opts ...grpc.CallOption) (*GetPublicShareResponse, error)
	// Gets share information for a single share by its unlisted token.
	// MUST return CODE_NOT_FOUND if the share does not exist.
	GetPublicShareByToken(ctx context.Context, in *GetPublicShareByTokenRequest, opts ...grpc.CallOption) (*GetPublicShareByTokenResponse, error)
	// List the shares the authenticated principal has created,
	// both as owner and creator. If a filter is specified, only
	// shares satisfying the filter MUST be returned.
	ListPublicShares(ctx context.Context, in *ListPublicSharesRequest, opts ...grpc.CallOption) (*ListPublicSharesResponse, error)
	// Updates a share.
	// MUST return CODE_NOT_FOUND if the share reference does not exist.
	UpdatePublicShare(ctx context.Context, in *UpdatePublicShareRequest, opts ...grpc.CallOption) (*UpdatePublicShareResponse, error)
}

type linkAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewLinkAPIClient(cc grpc.ClientConnInterface) LinkAPIClient {
	return &linkAPIClient{cc}
}

func (c *linkAPIClient) CreatePublicShare(ctx context.Context, in *CreatePublicShareRequest, opts ...grpc.CallOption) (*CreatePublicShareResponse, error) {
	out := new(CreatePublicShareResponse)
	err := c.cc.Invoke(ctx, LinkAPI_CreatePublicShare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkAPIClient) RemovePublicShare(ctx context.Context, in *RemovePublicShareRequest, opts ...grpc.CallOption) (*RemovePublicShareResponse, error) {
	out := new(RemovePublicShareResponse)
	err := c.cc.Invoke(ctx, LinkAPI_RemovePublicShare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkAPIClient) GetPublicShare(ctx context.Context, in *GetPublicShareRequest, opts ...grpc.CallOption) (*GetPublicShareResponse, error) {
	out := new(GetPublicShareResponse)
	err := c.cc.Invoke(ctx, LinkAPI_GetPublicShare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkAPIClient) GetPublicShareByToken(ctx context.Context, in *GetPublicShareByTokenRequest, opts ...grpc.CallOption) (*GetPublicShareByTokenResponse, error) {
	out := new(GetPublicShareByTokenResponse)
	err := c.cc.Invoke(ctx, LinkAPI_GetPublicShareByToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkAPIClient) ListPublicShares(ctx context.Context, in *ListPublicSharesRequest, opts ...grpc.CallOption) (*ListPublicSharesResponse, error) {
	out := new(ListPublicSharesResponse)
	err := c.cc.Invoke(ctx, LinkAPI_ListPublicShares_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *linkAPIClient) UpdatePublicShare(ctx context.Context, in *UpdatePublicShareRequest, opts ...grpc.CallOption) (*UpdatePublicShareResponse, error) {
	out := new(UpdatePublicShareResponse)
	err := c.cc.Invoke(ctx, LinkAPI_UpdatePublicShare_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LinkAPIServer is the server API for LinkAPI service.
// All implementations should embed UnimplementedLinkAPIServer
// for forward compatibility
type LinkAPIServer interface {
	// Creates a new share.
	// MUST return CODE_NOT_FOUND if the resource reference does not exist.
	// MUST return CODE_ALREADY_EXISTS if the share already exists for the 4-tuple consisting of
	// (owner, shared_resource, grantee).
	// New shares MUST be created in the state SHARE_STATE_PENDING.
	CreatePublicShare(context.Context, *CreatePublicShareRequest) (*CreatePublicShareResponse, error)
	// Removes a share.
	// MUST return CODE_NOT_FOUND if the share reference does not exist.
	RemovePublicShare(context.Context, *RemovePublicShareRequest) (*RemovePublicShareResponse, error)
	// Gets share information for a single share.
	// MUST return CODE_NOT_FOUND if the share reference does not exist.
	GetPublicShare(context.Context, *GetPublicShareRequest) (*GetPublicShareResponse, error)
	// Gets share information for a single share by its unlisted token.
	// MUST return CODE_NOT_FOUND if the share does not exist.
	GetPublicShareByToken(context.Context, *GetPublicShareByTokenRequest) (*GetPublicShareByTokenResponse, error)
	// List the shares the authenticated principal has created,
	// both as owner and creator. If a filter is specified, only
	// shares satisfying the filter MUST be returned.
	ListPublicShares(context.Context, *ListPublicSharesRequest) (*ListPublicSharesResponse, error)
	// Updates a share.
	// MUST return CODE_NOT_FOUND if the share reference does not exist.
	UpdatePublicShare(context.Context, *UpdatePublicShareRequest) (*UpdatePublicShareResponse, error)
}

// UnimplementedLinkAPIServer should be embedded to have forward compatible implementations.
type UnimplementedLinkAPIServer struct {
}

func (UnimplementedLinkAPIServer) CreatePublicShare(context.Context, *CreatePublicShareRequest) (*CreatePublicShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePublicShare not implemented")
}
func (UnimplementedLinkAPIServer) RemovePublicShare(context.Context, *RemovePublicShareRequest) (*RemovePublicShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePublicShare not implemented")
}
func (UnimplementedLinkAPIServer) GetPublicShare(context.Context, *GetPublicShareRequest) (*GetPublicShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPublicShare not implemented")
}
func (UnimplementedLinkAPIServer) GetPublicShareByToken(context.Context, *GetPublicShareByTokenRequest) (*GetPublicShareByTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPublicShareByToken not implemented")
}
func (UnimplementedLinkAPIServer) ListPublicShares(context.Context, *ListPublicSharesRequest) (*ListPublicSharesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPublicShares not implemented")
}
func (UnimplementedLinkAPIServer) UpdatePublicShare(context.Context, *UpdatePublicShareRequest) (*UpdatePublicShareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePublicShare not implemented")
}

// UnsafeLinkAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LinkAPIServer will
// result in compilation errors.
type UnsafeLinkAPIServer interface {
	mustEmbedUnimplementedLinkAPIServer()
}

func RegisterLinkAPIServer(s grpc.ServiceRegistrar, srv LinkAPIServer) {
	s.RegisterService(&LinkAPI_ServiceDesc, srv)
}

func _LinkAPI_CreatePublicShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePublicShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkAPIServer).CreatePublicShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkAPI_CreatePublicShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkAPIServer).CreatePublicShare(ctx, req.(*CreatePublicShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkAPI_RemovePublicShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePublicShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkAPIServer).RemovePublicShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkAPI_RemovePublicShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkAPIServer).RemovePublicShare(ctx, req.(*RemovePublicShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkAPI_GetPublicShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkAPIServer).GetPublicShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkAPI_GetPublicShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkAPIServer).GetPublicShare(ctx, req.(*GetPublicShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkAPI_GetPublicShareByToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicShareByTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkAPIServer).GetPublicShareByToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkAPI_GetPublicShareByToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkAPIServer).GetPublicShareByToken(ctx, req.(*GetPublicShareByTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkAPI_ListPublicShares_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPublicSharesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkAPIServer).ListPublicShares(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkAPI_ListPublicShares_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkAPIServer).ListPublicShares(ctx, req.(*ListPublicSharesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LinkAPI_UpdatePublicShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePublicShareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LinkAPIServer).UpdatePublicShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LinkAPI_UpdatePublicShare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LinkAPIServer).UpdatePublicShare(ctx, req.(*UpdatePublicShareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LinkAPI_ServiceDesc is the grpc.ServiceDesc for LinkAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LinkAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cs3.sharing.link.v1beta1.LinkAPI",
	HandlerType: (*LinkAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePublicShare",
			Handler:    _LinkAPI_CreatePublicShare_Handler,
		},
		{
			MethodName: "RemovePublicShare",
			Handler:    _LinkAPI_RemovePublicShare_Handler,
		},
		{
			MethodName: "GetPublicShare",
			Handler:    _LinkAPI_GetPublicShare_Handler,
		},
		{
			MethodName: "GetPublicShareByToken",
			Handler:    _LinkAPI_GetPublicShareByToken_Handler,
		},
		{
			MethodName: "ListPublicShares",
			Handler:    _LinkAPI_ListPublicShares_Handler,
		},
		{
			MethodName: "UpdatePublicShare",
			Handler:    _LinkAPI_UpdatePublicShare_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cs3/sharing/link/v1beta1/link_api.proto",
}
